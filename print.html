<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Gluon Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Gluon is a static, type inferred and embeddable language written in Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li><ol class="section"><li><a href="dissecting-hello-world.html"><strong aria-hidden="true">1.1.</strong> Dissecting Hello World</a></li><li><a href="using-the-repl.html"><strong aria-hidden="true">1.2.</strong> Using the REPL</a></li></ol></li><li><a href="syntax-and-semantics.html"><strong aria-hidden="true">2.</strong> Syntax and semantics</a></li><li><a href="metadata.html"><strong aria-hidden="true">3.</strong> Metadata</a></li><li><a href="modules.html"><strong aria-hidden="true">4.</strong> Modules</a></li><li><a href="embedding-api.html"><strong aria-hidden="true">5.</strong> Embedding API</a></li><li><ol class="section"><li><a href="marshalling-types.html"><strong aria-hidden="true">5.1.</strong> Marshalling values</a></li></ol></li><li><a href="standard-types-and-functions.html"><strong aria-hidden="true">6.</strong> Standard types and functions</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Gluon Documentation</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#getting-started" id="getting-started"><h1>Getting started</h1></a>
<p>To get started with gluon we must first have a way to compile and run Gluon programs. The fastest way to get that is to download one of the pre-built binaries for Linux, Windows, OSX or FreeBSD from https://github.com/gluon-lang/gluon/releases. Alternatively, if you have a Rust compiler and Cargo installed you may install it with <code>cargo install gluon_repl</code>.</p>
<p>Once installed you can verify that it works by saving the following program into a file named <code>hello_world.glu</code> and then compile and run it with <code>gluon hello_world.glu</code>.</p>
<pre><code class="language-gluon">let io = import! std.io
io.println &quot;Hello world!&quot;
</code></pre>
<p>If everything works the program should have printed <code>Hello world!</code> to your terminal.</p>
<a class="header" href="print.html#dissecting-hello-world" id="dissecting-hello-world"><h1>Dissecting Hello World</h1></a>
<pre><code class="language-gluon">let io = import! std.io
io.println &quot;Hello world!&quot;
</code></pre>
<p>There are a number of things going on in the hello world example so lets break them down one step at a time.</p>
<pre><code class="language-gluon">let
</code></pre>
<p>Gluon uses the keyword <code>let</code> to bind values for later use.</p>
<pre><code class="language-gluon">import! std.io
</code></pre>
<p><code>import!</code> is a builtin macro which loads the contents of another module. In the example we use it to get access to the standard library's <code>io</code> module. Since it appeared on the right side of <code>let io =</code> we thus bound the <code>std.io</code> module to the <code>io</code> binding.</p>
<pre><code>io.println
</code></pre>
<p>Here we access the <code>println</code> function from the <code>io</code> module we bound earlier which is a function that lets us write strings to stdout.</p>
<pre><code class="language-gluon">&quot;Hello world!&quot;
</code></pre>
<p>Finally we create a string literal which gets passed to <code>println</code> to get printed.</p>
<a class="header" href="print.html#using-the-repl" id="using-the-repl"><h1>Using the REPL</h1></a>
<p>Though it is possible to continue running any programs by saving it to a file and running it with <code>gluon my_script.glu</code> there is an easier way to go about it when you want to experiment quickly with small programs. By running <code>gluon -i</code>, gluon starts in &quot;interactive&quot; mode, giving you a REPL where you may evaluate expressions and inspect their results. Try evaluating some simple arithmetic expressions to see that it works.</p>
<pre><code>&gt; 1 + 2
3
&gt; 100 * 3 + 4
304
&gt; 3.14 * 10.0
31.400000000000002
</code></pre>
<p>Evaluating only a single expression can get quite unwieldy so if we want to break something up into multiple steps we can use <code>let</code> to give a name to an expression.</p>
<pre><code>&gt; let pi_2 = 3.14 * 2.0
6.28
&gt; pi_2 * 3.0
18.84
</code></pre>
<p>These are the basic parts of the REPL and if you want to you can try writing hello world again by using the features above.</p>
<p>If you still have the <code>hello_world.glu</code> file around there is another way to run it from inside the REPL by using the special <code>:script</code> (<code>:s</code>) command.</p>
<pre><code>&gt; :s hello_world.glu
Hello World!
</code></pre>
<p>There are a few other of these special commands as well and you can find them all with <code>:help</code> (<code>:h</code>).</p>
<pre><code>&gt; :type 1
Int
&gt; :info std.io.println
std.io.println: String -&gt; IO ()
&gt; :kind std.option.Option
Type -&gt; Type
</code></pre>
<p>Finally you may quit the REPL using the <code>:quit</code> (<code>:q</code>) command or using <code>&lt;CTRL-D&gt;</code>.</p>
<a class="header" href="print.html#syntax-and-semantics" id="syntax-and-semantics"><h1>Syntax and semantics</h1></a>
<p>Gluon is a functional language at heart, basing its syntax on languages such as F#, OCaml and Haskell.
The syntax may thus look strange if you are coming from C-like languages but don't be discouraged!
There is actually very little syntax to learn.</p>
<p>If, on the other hand, you are familiar with functional languages you will be right at home. Roughly speaking, Gluon takes the expression syntax from F# and OCaml and uses the type syntax of Haskell.</p>
<a class="header" href="print.html#identifiers-and-literals" id="identifiers-and-literals"><h3>Identifiers and Literals</h3></a>
<p>The simplest syntactical elements in Gluon are identifiers and literals and none of them should be especially surprising if you are experienced in programming.</p>
<p>Identifiers are a sequence of alphanumeric characters including underscore (&quot;_&quot;) which are required to start with either a letter or an underscore. Literals come in four different forms - integer, float, string and character literals.</p>
<pre><code class="language-f#">// An identifier
abc123_

// An integer literal

42
// A float literal
3.14

// A string literal
&quot;Hello world&quot;

// A raw string literal
r&quot;Can contain newlines
world&quot;
r#&quot;With # as delimiters raw strings can also contain quotes without escaping `&quot;` &quot;#
r###&quot; &quot;## &quot;###

// A character literal
'e'
</code></pre>
<a class="header" href="print.html#comments" id="comments"><h3>Comments</h3></a>
<p>Comments should be immediately familiar if you are accustomed to C-like languages.</p>
<p><code>//</code> starts a line comment which is ended by a newline</p>
<p><code>/*</code> starts a block comment which is ended by <code>*/</code></p>
<a class="header" href="print.html#functions" id="functions"><h3>Functions</h3></a>
<pre><code class="language-f#">f x &quot;argument&quot; 3
</code></pre>
<p>Being a functional language, functions are everywhere. Because of this, calling functions have an intentionally minimalistic syntax where there is no need to enclose arguments as a parenthesized list of arguments. Instead, arguments are separated by whitespace.</p>
<p>Another way of calling a function is through infix notation since gluon implements all operators as just functions.</p>
<pre><code class="language-f# rust">1 + 2 // Calls the + function on 1 and 2
</code></pre>
<pre><code class="language-f# rust">(+) 1 2 // Parenthesizing an operator makes it possible to use in a normal function call
</code></pre>
<p>It is important to note that function application binds harder than any binary operator.</p>
<pre><code class="language-f# rust">(+) 0 1 - (+) 2 3 // Equivalent to (0 + 1) - (2 + 3)
</code></pre>
<a class="header" href="print.html#variable-bindings" id="variable-bindings"><h3>Variable bindings</h3></a>
<p>Any language more complex than Hello world is bound to require variable bindings which serve to bind some value to a name
allowing it to be used later.</p>
<pre><code class="language-f# rust">let x = 1 + 2 in x // Returns 3
</code></pre>
<p>You may rightly be wondering about the <code>in x</code> part. gluon takes a strong stance against statements in an effort to keep things consistent. Thus only writing <code>let x = 1 + 2</code> will be met with a syntax error about a missing <code>in</code> keyword which is what defines the actual value returned from the <code>let</code> expression.</p>
<p>Let bindings also allow functions to be defined which is done by listing the arguments between the bound identifier and <code>=</code></p>
<pre><code class="language-f# rust">// Defines the `id` function which takes a single argument and returns it.
let id x = x in id 1 // Returns 1
</code></pre>
<p>Mutually recursive functions can be defined using <code>let</code> by writing <code>and</code> before each successive binding.</p>
<pre><code class="language-f#">let f x = g x
and g x = f x
in f 1 // Never returns
</code></pre>
<a class="header" href="print.html#if-expressions" id="if-expressions"><h3>If expressions</h3></a>
<p>The simplest control flow expression is the <code>if</code> expression. It evaluates a boolean expression, taking the first branch if the boolean evaluates to <code>True</code>, and taking the second if it evaluates to <code>False</code></p>
<pre><code class="language-f# rust">if True then 1 else 0
</code></pre>
<a class="header" href="print.html#record-expressions" id="record-expressions"><h3>Record expressions</h3></a>
<p>To create more complex data types, Gluon has first class records. Records can be used to couple data that is logically grouped into a single type.</p>
<pre><code class="language-f# rust">{ pi = 3.14, add1 = (+) 1.0 }
</code></pre>
<p>To access the fields of a record, <code>.</code> is used.</p>
<pre><code class="language-f# rust">let record = { pi = 3.14, add1 = (+) 1.0 }
in record.pi // Returns 3.14
</code></pre>
<p>Field assignments can be omitted if there is a variable in scope with the same name as the field.</p>
<pre><code class="language-f# rust">let id x = x
in { id }
</code></pre>
<p>The <code>..</code> operator can be used at the end of a record expression to take all fields of one record and fill the constructed record.</p>
<pre><code class="language-f# rust">let large_record = { x = 1, y = 2, name = &quot;gluon&quot; }
in
// Results in a record with type
// { field : Bool, x : Int, y : Int, name : String }
{
    field = True,
    ..
    large_record
}
</code></pre>
<a class="header" href="print.html#array-expressions" id="array-expressions"><h3>Array expressions</h3></a>
<p>Arrays can be constructed with array literals.</p>
<pre><code class="language-f# rust">// Results in an `Array Int`
[1, 2, 3, 4]
</code></pre>
<p>Since Gluon is statically typed all values must be of the same type. This allows the Gluon interpreter to avoid tagging each value individually which makes types such as <code>Array Byte</code> be convertible into Rust's <code>&amp;[u8]</code> type without any allocations.</p>
<pre><code class="language-f#">// ERROR:
// Types do not match:
//        Expected: Int
//        Found: String
[1, &quot;&quot;]
</code></pre>
<p>Functions to operate on arrays can be found on the <code>array</code> module.</p>
<pre><code class="language-f#">array.len [1, 2, 3]
</code></pre>
<a class="header" href="print.html#variants" id="variants"><h3>Variants</h3></a>
<p>While records are great for grouping related data together, there is often a need to have data which can be one of several variants. Unlike records, variants need to be defined before they can be used.</p>
<pre><code class="language-f# rust">type MyOption a = | Some a | None
Some 1
</code></pre>
<a class="header" href="print.html#match-expressions" id="match-expressions"><h3>Match expressions</h3></a>
<p>To allow variants to be unpacked so their contents can be retrieved, Gluon has the <code>match</code> expression.</p>
<pre><code class="language-f# rust">match None with
| Some x -&gt; x
| None -&gt; 0
</code></pre>
<p>Here, we write out a pattern for each of the variant's constructors and the value we pass in (<code>None</code> in this case) is matched to each of these patterns. When a matching pattern is found, the expression on the right of <code>-&gt;</code> is evaluated with each of the constructor's arguments bound to variables.</p>
<p><code>match</code> expressions can also be used to unpack records.</p>
<pre><code class="language-f# rust">match { x = 1.0, pi = 3.14 } with
| { x = y, pi } -&gt; y + pi

// Patterns can be nested as well
match { x = Some (Some 123) } with
| { x = Some None } -&gt; 0
| { x = Some (Some x) } -&gt; x
| { x = None } -&gt; -1
</code></pre>
<p><code>let</code> bindings can also match and unpack on data but only with irrefutable patterns. In other words, only with patterns which cannot fail.</p>
<pre><code class="language-f# ignore">// Matching on records will always succeed since they are the only variant
let { x = y, pi } = { x = 1.0, pi = 3.14 }
in y + pi

// These will be rejected however as `let` can only handle one variant (`Some` in this example)
let Some x = None
let Some y = Some 123
x + y
</code></pre>
<a class="header" href="print.html#tuple-expressions" id="tuple-expressions"><h3>Tuple expressions</h3></a>
<p>Gluon also have tuple expressions for when you don't have sensible names for your fields.</p>
<pre><code class="language-f# rust">(1, &quot;&quot;, 3.14) // (Int, String, 3.14)
</code></pre>
<p>Similarily to records they can be unpacked with <code>match</code> and <code>let</code>.</p>
<pre><code class="language-f#">match (1, None) with
| (x, Some y) -&gt; x + y
| (x, None) -&gt; x

let (a, b) = (1.0, 2.14)
a + b
</code></pre>
<p>Infact, tuples are only syntax sugar over records with fields named after numbers (<code>_0</code>, <code>_1</code>, ...) which makes the above equivalent to the following code.</p>
<pre><code class="language-f#">match { _0 = 1, _1 = None } with
| { _0 = x, _1 = Some y } -&gt; x + y
| { _0 = x, _1 = None } -&gt; x

let { _0 = a, _1 = b } = { _0 = 1.0, _1 = 2.14 }
a + b
</code></pre>
<p>While that example is obviously less readable the tuple syntax, the important thing to note is that tuples equivalency with records allows one to access the fields of a tuple directly without unpacking.</p>
<pre><code class="language-f# rust">(0, 3.14)._1 // 3.14
</code></pre>
<a class="header" href="print.html#lambda-expressions" id="lambda-expressions"><h3>Lambda expressions</h3></a>
<p>While we have seen that functions can be defined in let expressions it is often valuable to define a function without giving it an explicit name.</p>
<pre><code class="language-f# rust">// \(&lt;identifier)* -&gt; &lt;expr&gt;
\x y -&gt; x + y - 10
// Equivalent to
let f x y = x + y - 10 in f
</code></pre>
<a class="header" href="print.html#type-expressions" id="type-expressions"><h3>Type expressions</h3></a>
<p>Gluon allows new types to be defined through the <code>type</code> expression which, just like <code>let</code>, requires <code>in &lt;expression&gt;</code> to be written at the end to ensure it returns a value.</p>
<pre><code class="language-f# rust">// type &lt;identifier&gt; &lt;identifier&gt;* = &lt;type&gt; in &lt;expression&gt;
type MyOption a = | None | Some a
let divide x y : Int -&gt; Int -&gt; MyOption Int =
    if (x / y) * y == x then
        Some (x / y)
    else
        None
in divide 10 4
</code></pre>
<p>An important difference from many languages however is that <code>type</code> only defines aliases. This means that all types in the example below are actually equivalent to each other.</p>
<pre><code class="language-f# rust">type Type1 = { x: Int }
type Type2 = Type1
type Type3 = { x: Int }
let r1 : Type1 = { x = 0 }
let r2 : Type2 = r1
let r3 : Type3 = r2
in r1
</code></pre>
<p>Mutually recursive types can be defined by writing <code>and</code> between each definition.</p>
<pre><code class="language-f# rust">type SExpr_ = | Atom String | Cons SExpr SExpr
and SExpr = { location: Int, expr: SExpr_ }
in Atom &quot;name&quot;
</code></pre>
<a class="header" href="print.html#do-expressions" id="do-expressions"><h3>Do expressions</h3></a>
<p><code>do</code> expressions are syntax sugar over the commonly used <code>Monad</code> type which is used to encapsulate side-effects. By using <code>do</code> instead of <code>&gt;&gt;=</code> or <code>flat_map</code> we can write our code in a sequential manner instead of the closures necessary for sugar free versions. Note <code>do</code> still requires a <code>flat_map</code> binding to be in scope with the correct type or else you will get an error during typechecking.</p>
<pre><code class="language-f#">Some 1 &gt;&gt;= (\x -&gt; Some (x + 2))
// or
flat_map (\x -&gt; Some (x + 2)) (Some 1)

// are equivalent to

do x = Some 1
Some (x + 2)
</code></pre>
<a class="header" href="print.html#indentation" id="indentation"><h3>Indentation</h3></a>
<p>If you have been following along this far, you may be think that the syntax so far is pretty limiting. In particular, you wouldn't be wrong in thinking that the <code>let</code> and <code>type</code> syntax are clunky due to their need to be closed by the <code>in</code> keyword. Luckily, Gluon offers a more convenient way of writing bindings by relying on indentation.</p>
<p>When a token starts on the same column as an unclosed <code>let</code> or <code>type</code> expression, the lexer implicitly inserts an <code>in</code> token which closes the declaration part and makes the following expression into the body.</p>
<pre><code class="language-f# rust">let add1 x = x + 1
add1 11 // `in` will be inserted automatically since `add1 11` starts on the same line as the opening `let`
</code></pre>
<p>If a token starts on the same column as an earlier expression, but there is not an unclosed <code>type</code> or <code>let</code> expression, Gluon treats the code as a block expression, meaning each expression is run sequentially, returning the value of the last expression.</p>
<pre><code class="language-f#">do_something1 ()
do_something2 () // `do_something1 ()` is run, then `do_something_2`. The result of `type ...` is the result of the expression
type PrivateType = | Private Int
let x = Private (do_something3 ())
do_something3 ()
match x with
| Private y -&gt; do_something4 x
</code></pre>
<p>Indented blocks can be used to limit the scope of some variables.</p>
<pre><code class="language-f# rust">let module =
    let id x = x
    type MyInt = Int
    { MyInt, id, pi = 3.14 }

module.id module.pi
</code></pre>
<p>Which is equivalent to:</p>
<pre><code class="language-f# rust">let module =
    let id x = x
    in
    type MyInt = Int
    in { MyInt, id, pi = 3.14 }
in
module.id module.pi
</code></pre>
<a class="header" href="print.html#typesystem" id="typesystem"><h2>Typesystem</h2></a>
<p>In gluon, identifiers starting with an uppercase letter is a type whereas identifiers starting with a lowercase letter are type variables.</p>
<a class="header" href="print.html#function-types" id="function-types"><h3>Function types</h3></a>
<pre><code>&lt;type&gt; -&gt; &lt;type&gt;
</code></pre>
<p>Function types are written using the <code>(-&gt;)</code> operator, which is right associative. This means that the function type <code>Int -&gt; (Int -&gt; Int)</code> (A function taking one argument of Int and returning a function of <code>Int -&gt; Int</code>) can be written as <code>Int -&gt; Int -&gt; Int</code>.</p>
<a class="header" href="print.html#record-type" id="record-type"><h3>Record type</h3></a>
<pre><code>type_identifier := [A-Z][A-Za-z_0-9]*
variable_identifier := [a-z][A-Za-z_0-9]*

field := &lt;type_identifier&gt; &lt;variable_identifier&gt;* = &lt;type&gt;
       | &lt;type_identifier&gt;
       | &lt;variable_identifier&gt; : &lt;type&gt;

record_type := { (field,)* }

// Example
{
    Float,
    BinaryOp = Float -&gt; Float -&gt; Float,
    pi : Float,
    sin : Float -&gt; Float
}
</code></pre>
<p>Records are Gluon's main way of creating associating related data and they should look quite familiar if you are familiar with dynamic languages such as javascript. Looks can be deceiving however as gluon's records are more similar to a struct in Rust or C as the order of the fields are significant, <code>{ x : Int, y : String } != { y : String, x : Int }</code>. Furthermore, records are immutable, meaning fields cannot be added nor removed and the values within cannot be modified.</p>
<p>In addition to storing values, records also have a secondary function of storing types which is Gluon's way of exporting types. If you have used modules in an ML language, this may look rather familiar. Looks can be deceiving however as 'type fields' must match exactly in gluon which means there is no subtyping relationship between records (<code>{ Test = { x : Int } }</code> is not a subtype of <code>{ Test = Float }</code>). This may change in the future.</p>
<pre><code class="language-f#">{ Test = { x : Int } }
</code></pre>
<a class="header" href="print.html#enumeration-type" id="enumeration-type"><h3>Enumeration type</h3></a>
<pre><code>( | &lt;identifier&gt; (&lt;type&gt;)* )*

| Err e | Ok t
</code></pre>
<p>Gluon also has a second way of grouping data which is the enumeration type which allows you to represent a value being one of several variants. In the example above is the representation of Gluon's standard <code>Result</code> type. It represents either the value having been successfully computed (<code>Ok t</code>) or that an error occurred (<code>Err e</code>).</p>
<a class="header" href="print.html#alias-type" id="alias-type"><h3>Alias type</h3></a>
<pre><code>&lt;identifier&gt; (&lt;type&gt;)*
Int
Float
Option Int
Ref String
</code></pre>
<p>The last kind of type which Gluon has is the alias type. An alias type explicitly names some underlying type which can either be one of the three types mentioned above or an abstract type which is the case for the <code>Int</code>, <code>String</code> and <code>Ref</code> types. If the underlying type is abstract, then the type is only considered equivalent to itself (ie if you define an abstract type of <code>MyInt</code> which happens to have the same representation as <code>Int</code> the typechecker will consider these two types as being distinct).</p>
<a class="header" href="print.html#higher-kinded-types" id="higher-kinded-types"><h3>Higher-kinded types</h3></a>
<p>Higher-kinded types are a fairly abstract concept in Gluon and you may create entire programs without any knowledge about them. Sometimes they are a very valuable tool to have, as they can be used to create very powerful abstractions.</p>
<p>Just as all values such as <code>0 : Int</code>, <code>&quot;Hello World!&quot; : String</code> and <code>Some 4.0 : Option Float</code> each have a type, these types themselves have their own 'type' or the 'kind' as it is called. For the types of concrete values the <code>Kind</code> is always <code>Type</code> so for the earlier examples <code>Int : Type</code>, <code>String : Type</code> and <code>Option Float : Type</code>. That is not very useful on its own but it becomes more interesting when we consider the kind of <code>Option : Type -&gt; Type</code>. <code>Type -&gt; Type</code> looks rather like the type of a function such as <code>show_int : Int -&gt; String</code> but, instead of taking a value, it takes a type and produces a new type. In effect, this lets us abstract over types instead of just over values. This abstraction facility can be seen in the <code>Functor : (Type -&gt; Type) -&gt; Type</code> type which takes a type with kind <code>Type -&gt; Type</code> as argument which is exactly the kind of <code>Option</code> (or <code>List</code>, <code>Result a</code>).</p>
<a class="header" href="print.html#universal-quantification" id="universal-quantification"><h3>Universal quantification</h3></a>
<p><em>First draft</em></p>
<p>Universal quantification is what Gluon's &quot;generic types&quot; are called. Consider the identity function in Rust.</p>
<pre><code class="language-rust ignore">fn id&lt;T&gt;(x: T) -&gt; T {
    x
}
</code></pre>
<p>In Gluon the same function would be written in the following way if it were fully annotated.</p>
<pre><code class="language-f#">let id x : forall a . a -&gt; a = x
</code></pre>
<pre><code class="language-f#">// Types can of course be omitted in which the same type as above will be inferred
let id x = x
// Unbound type variables (`a` in this example) are allowed, in which case a `forall` will be
// inserted at the at the &quot;top&quot; of the type (same place as the type above)
let id x : a -&gt; a = x
</code></pre>
<p>So in simple case, <code>forall</code> is no different from declaring type parameters to a function in Rust. But <code>forall</code> also serves more advanced use cases and is at the center when it comes to making Gluon's records work as modules.</p>
<pre><code class="language-f#">let module =
    let id x = x

    { id }

module.id 0
module.id &quot;&quot;
</code></pre>
<p>If we were to emulate the above code in Rust we would probably end up with something like this code.</p>
<pre><code class="language-rust ignore">struct Module&lt;T&gt; {
    id : Box&lt;Fn(T) -&gt; T&gt;,
}

let module = Module {
    id: Box::new(|x| x),
};
(module.id)(0);
(module.id)(&quot;&quot;);
</code></pre>
<p>Alas, this does not work in Rust since <code>module</code> will be inferred to the type <code>Module&lt;i32&gt;</code> which makes the second call to <code>id</code> a type error. In gluon it works as the type of <code>module</code> is actually <code>{ id : forall a . a -&gt; a }</code> and not <code>forall a . { id : a -&gt; a }</code> which is the closest analogue to the Rust example.</p>
<p>Intuitively, we can say that since gluon lets <code>forall</code> be specified inside types we can avoid specializing the type (in this case <code>forall a . a -&gt; a</code>) which lets us specialize <code>module.id</code> once for each call to <code>id</code> instead of specializing the entire module at once.</p>
<p>While all of this looks quite complex, it should for the most part not matter when writing code and common idioms will just work as expected!</p>
<a class="header" href="print.html#implicit-arguments" id="implicit-arguments"><h3>Implicit arguments</h3></a>
<p>Sometimes, there is a need to overload a name with multiple differing implementations and let the compiler chose the correct implementation. If you have written any amount of Gluon code so far, you are likely to have already encountered this with numeric operators such as <code>(+)</code> or comparison operators such as <code>(==)</code>. If you inspect the types of these functions you will find that the first argument of these functions look a little bit different from normal functions.</p>
<pre><code class="language-gluon">(==): : forall a . [std.prelude.Eq a] -&gt; a -&gt; a -&gt; std.types.Bool
(+): forall a . [std.prelude.Num a] -&gt; a -&gt; a -&gt; a
</code></pre>
<p>This different looking argument is an implicit argument which means that you do not need to pass a value for this argument, instead, the compiler will try to find a value with a type that matches the type signature. So if you were to call <code>1 == 2</code> the compiler will see that the type variable <code>a</code> has been unified to <code>Int</code>. Then when the implicit argument is resolved it will look for a value with the type <code>Eq Int</code>.</p>
<p>Since searching all possible bindings currently in scope would introduce to many ambiguity errors the compiler does not search all bindings when trying to determine an implicit argument. Instead, whether a binding is considered for implicit resolution is controlled by the <code>#[implicit]</code> attribute. When marking a <code>let</code> binding as <code>#[implicit]</code> and this binding is in scope it will be considered as a candidate for all implicit arguments. The <code>#[implicit]</code> attribute can also be set on a <code>type</code> binding in which case it applied to all <code>let</code> bindings which has the type declared by the <code>type</code> binding.</p>
<pre><code class="language-f# rust">#[implicit]
type Test = | Test ()
let f y: [a] -&gt; a -&gt; a = y
let i = Test ()
// `i` gets selected as the implicit argument since `#[implicit]` is marked on the type and `i : Test`
()
</code></pre>
<p>Since importing each individual binding used as an implicit argument quickly becomes tedious there is a short-hand to bring all implicit bindings from a record into scope.</p>
<pre><code class="language-f# ignore">let { eq, ord } = import! std.int
1 == 1 &amp;&amp; 1 &lt; 2
</code></pre>
<pre><code class="language-f# ignore">// Also brings in `show`, `num` ...
let { ? } = import! std.int
1 == 1 &amp;&amp; 1 &lt; 2
</code></pre>
<p>For standard types such as <code>Int</code>, <code>Float</code>, <code>String</code>, <code>Bool</code> and <code>Option</code> this gets injected through the implicit prelude that is inserted before all code which lets <code>==</code>, <code>&lt;</code> etc to work out of the box.</p>
<a class="header" href="print.html#passing-implicit-arguments-explicitly" id="passing-implicit-arguments-explicitly"><h4>Passing implicit arguments explicitly</h4></a>
<p>If you only use implicit functions as explained above then it might just seem like a different name for traits (Rust) or type classes (Haskell). While it is true that the main reason for implicit arguments is to emulate traits/type classes implicit arguments is more powerful than those approaches as it is also possible to override the implicit resolution and instead give the argument explicitly by prefixing the argument with <code>?</code>.</p>
<pre><code class="language-f# rust">let list @ { List } = import! std.list
// Make a custom equality function which returns true regardless of the elements of the list
#[infix(left, 4)]
let (===) = (list.eq ?{ (==) = \x y -&gt; True }).(==)
Cons 1 (Cons 2 Nil) === Cons 3 (Cons 4 Nil)
</code></pre>
<p>The inverse also works when defining a function with implicit arguments. By prefixing an argument by <code>?</code> an implicit arguments will be given a name inside the function (if <code>?</code> is not given in a function definition the argument will only be available for implicit resolution).</p>
<pre><code class="language-f# rust">let eq ?a : [Eq a] -&gt; Eq (Option a) = {
    (==) = \l r -&gt;
        match (l, r) with
        | (Some l_val, Some r_val) -&gt; a.(==) l_val r_val
        | (None, None) -&gt; True
        | _ -&gt; False,
}
()
</code></pre>
<a class="header" href="print.html#importing-modules" id="importing-modules"><h2>Importing modules</h2></a>
<p>As is often the case, it is convenient to separate code into multiple files which can later be imported and used from multiple other files. To do this, we can use the <code>import!</code> macro which takes a single string literal as argument and loads and compiles that file at compile time before the importing module is compiled.</p>
<p>For example, say that we need the <code>assert</code> function from the <code>test</code> module which can be found at <code>std/test.glu</code>. We might write something like this:</p>
<pre><code class="language-f# rust">let { assert } = import! std.test
assert (1 == 1)
</code></pre>
<a class="header" href="print.html#writing-modules" id="writing-modules"><h2>Writing modules</h2></a>
<p>Importing standard modules is all well and good but it is also necessary to write your own once a program starts getting too big for a single file. As it turns out, if you have been following along so far, you already know everything about writing a module! Creating and loading a module in gluon entails creating a file containing an expression which is then loaded and evaluated using <code>import!</code>. <code>import!</code> is then just the value of the evaluated expression.</p>
<pre><code class="language-f#">// module.glu
type Named a = { name: String, value: a }
let twice f x = f (f x)
{ twice, Named }

//main.glu
let { twice, Named }  = import! &quot;module.glu&quot;
let addTwice = twice (\x -&gt; x + 1)
let namedFloat : Named Float = { name = &quot;pi&quot;, value = 3.14 }
addTwice 10
</code></pre>
<p>Though modules are most commonly a record, this does not have to be the case. If you wanted, you could write a module returning any other value as well.</p>
<pre><code class="language-f#">// pi.glu
3.14

//main.glu
let pi  = import! &quot;pi.glu&quot;
2 * pi * 10
</code></pre>
<a class="header" href="print.html#metadata" id="metadata"><h1>Metadata</h1></a>
<p>Sometimes we need a way to associate some extra information to a specific named binding and have it be visible whenever we refer to that name. The most common reason for this is documentation comments. When we write some documentation for a binding we would like this documentation to be visible whenever someone uses that binding.</p>
<p>For this reason gluon runs a &quot;metadata&quot; pass on all code in which &quot;metadata&quot; (such as documentation comments) gets statically propagated throughout the code.</p>
<pre><code class="language-f#">/// Adds one to the argument `x`
let add1 x = x + 1

/// Adds two to the argument `x`
let add2 x = x + 2

add1 // Looking up the metadata of this variable yields the documentation of `add1`

// It can't be statically determined which branch the `if` takes (since constant folding do not
// take place). Thus `addN` do not get any metadata from either `add1` or `add2`
let addN = if True then add1 else add2
addN
</code></pre>
<a class="header" href="print.html#attributes" id="attributes"><h2>Attributes</h2></a>
<p>In addtion to documentation comments gluon also has a special notion of attributes that get propagated in the same manner. These are specified using the following syntax.</p>
<pre><code>Attribute : #[ AttributeContents ]

AttributeContents :
      #[ IDENTIFIER ]
    | #[ IDENTIFIER ( TOKENS* ) ]
</code></pre>
<a class="header" href="print.html#infix" id="infix"><h3>#[infix(..)]</h3></a>
<pre><code class="language-f#">#[infix(&lt;left|right&gt;, &lt;NON-NEGATIVE INTEGER&gt;)]
</code></pre>
<p>The <code>#[infix]</code> attribute is used to specified the fixity and precedence of infix operators. This lets us specify that multiplication binds tighter that addition.</p>
<pre><code class="language-f#">#[infix(left, 6)]
let (+) ?num : [Num a] -&gt; a -&gt; a -&gt; a = num.(+)
#[infix(left, 7)]
let (*) ?num : [Num a] -&gt; a -&gt; a -&gt; a = num.(*)
</code></pre>
<a class="header" href="print.html#implicit" id="implicit"><h3>#[implicit]</h3></a>
<pre><code class="language-f#">#[implicit]
</code></pre>
<p>The <code>#[implicit]</code> attribute is used to mark value bindings or type bindings as usable for implicit resolution. If specified on a value binding then only that specific binding can be used on implicit resolution. If specified on a type binding then all bindings that has that type can be used in implicit resolution.</p>
<pre><code>// Can be used as an implicit argument
#[implicit]
let binding : MyType = ..

#[implicit]
type Eq a = { (==) : a -&gt; a -&gt; Bool }

// Can be used as an implicit argument
let eq_Int : Eq Int = ..
</code></pre>
<a class="header" href="print.html#derive" id="derive"><h3>#[derive(..)]</h3></a>
<pre><code class="language-f#">#[derive(IDENTIFIER)]
</code></pre>
<p>The <code>#[derive(..)]</code> attribute can be used on <code>type</code> bindings to generate implementations for some traits. Currently only <code>Eq</code> and <code>Show</code> can be derived and only non-recursive and self-recursive types are supported (mutually recursive types do not work for the moment).</p>
<pre><code class="language-f# rust">#[derive(Eq, Show)]
type Tree a = | Tip a | Branch (Tree a) (Tree a)

let tree = Branch (Tip 1) (Branch (Tip 2) (Tip 3))

show tree
tree == Tip 1
</code></pre>
<a class="header" href="print.html#dochidden" id="dochidden"><h3>#[doc(hidden)]</h3></a>
<pre><code class="language-f#">#[doc(hidden)]
</code></pre>
<p>The <code>#[doc(hidden)]</code> attribute hides the binding, omitting it from generated documentation.</p>
<a class="header" href="print.html#modules" id="modules"><h1>Modules</h1></a>
<a class="header" href="print.html#importing-modules-1" id="importing-modules-1"><h2>Importing modules</h2></a>
<p>As is often the case, it is convenient to separate code into multiple files which can later be imported and used from multiple other files. To do this, we can use the <code>import!</code> macro which takes a single string literal as argument and loads and compiles that file at compile time before the importing module is compiled.</p>
<p>For example, say that we need the <code>assert</code> function from the <code>test</code> module which can be found at <code>std/test.glu</code>. We might write something like this:</p>
<pre><code class="language-f# rust">let { assert } = import! std.test
assert (1 == 1)
</code></pre>
<a class="header" href="print.html#writing-modules-1" id="writing-modules-1"><h2>Writing modules</h2></a>
<p>Importing standard modules is all well and good but it is also necessary to write your own once a program starts getting too big for a single file. As it turns out, if you have been following along so far, you already know everything about writing a module! Creating and loading a module in gluon entails creating a file containing an expression which is then loaded and evaluated using <code>import!</code>. <code>import!</code> is then just the value of the evaluated expression.</p>
<pre><code class="language-f#">// module.glu
type Named a = { name: String, value: a }
let twice f x = f (f x)
{ twice, Named }

//main.glu
let { twice, Named }  = import! &quot;module.glu&quot;
let addTwice = twice (\x -&gt; x + 1)
let namedFloat : Named Float = { name = &quot;pi&quot;, value = 3.14 }
addTwice 10
</code></pre>
<p>Though modules are most commonly a record, this does not have to be the case. If you wanted, you could write a module returning any other value as well.</p>
<pre><code class="language-f#">// pi.glu
3.14

//main.glu
let pi  = import! &quot;pi.glu&quot;
2 * pi * 10
</code></pre>
<a class="header" href="print.html#embedding-api" id="embedding-api"><h1>Embedding API</h1></a>
<p>The API with which the host language interacts with Gluon is very important part of the library. While the complete API can be found in the <a href="https://docs.rs/gluon/*/gluon/index.html">Rustdoc</a>, this section will explain the most important parts. Please note that the API can change at any point and there are still some public functions which should actually be internal.</p>
<a class="header" href="print.html#creating-a-virtual-machine" id="creating-a-virtual-machine"><h3>Creating a virtual machine</h3></a>
<p>Before you are able to do anything with the library, you will need to create a virtual machine. The virtual machine is responsible for running Gluon programs and can be created with the <a href="https://docs.rs/gluon/*/gluon/fn.new_vm.html">new_vm</a> function.</p>
<a class="header" href="print.html#compiling-and-running-gluon-code" id="compiling-and-running-gluon-code"><h3>Compiling and running gluon code</h3></a>
<p>Once in possession of a <a href="https://docs.rs/gluon/*/gluon/struct.RootedThread.html">RootedThread</a>, you can compile and execute code using the <a href="https://docs.rs/gluon/*/gluon/struct.Compiler.html#method.run_expr">run_expr</a> method on the [Compiler][] builder type.</p>
<pre><code class="language-rust ignore">let vm = new_vm();
let (result, _) = Compiler::new()
    .run_expr::&lt;i32&gt;(&amp;vm, &quot;example&quot;, &quot;1 + 2&quot;)
    .ok();
assert_eq!(result, Some(3));
</code></pre>
<p>Notably, if we were to execute a script with side effects the code above will actually not run the side effects. To make gluon run side effects we need to set the <a href="https://docs.rs/gluon/*/gluon/struct.Compiler.html#method.run_io">run_io</a> flag on [Compiler][].</p>
<pre><code class="language-rust ignore">let vm = new_vm();

let script = r#&quot;
let io = import! std.io
io.print &quot;123&quot;
&quot;#;
// Returns an action which prints `123` when evaluated
Compiler::new()
    .run_expr::&lt;IO&lt;()&gt;&gt;(&amp;vm, &quot;example&quot;, script)
    .unwrap();
// Prints `123` to stdout
Compiler::new()
    .run_io(true)
    .run_expr::&lt;IO&lt;()&gt;&gt;(&amp;vm, &quot;example&quot;, script)
    .unwrap();
</code></pre>
<p>Often, it is either inconvenient or inefficient to compile and run code directly from source code. To write the above example in a more efficient way, we could instead load the <code>(+)</code> function and call it directly.</p>
<pre><code class="language-rust ignore">let vm = new_vm();
// Ensure that the prelude module is loaded before trying to access something from it
Compiler::new()
    .run_expr::&lt;OpaqueValue&lt;&amp;Thread, Hole&gt;&gt;(&amp;vm, &quot;example&quot;, r#&quot; import! std.prelude &quot;#)
    .unwrap();
let mut add: FunctionRef&lt;fn (i32, i32) -&gt; i32&gt; = vm.get_global(&quot;std.prelude.num_Int.(+)&quot;)
    .unwrap();
let result = add.call(1, 2);
assert_eq!(result, Ok(3));
</code></pre>
<a class="header" href="print.html#calling-rust-functions-from-gluon" id="calling-rust-functions-from-gluon"><h3>Calling Rust functions from gluon</h3></a>
<p>Gluon also allows native functions to be called from gluon. To do this we first need to define the function so it is available when running Gluon code.</p>
<pre><code class="language-rust ignore">fn factorial(x: i32) -&gt; i32 {
    if x &lt;= 1 {
        1
    } else {
        x * factorial(x - 1)
    }
}

fn load_factorial(vm: &amp;Thread) -&gt; vm::Result&lt;vm::ExternModule&gt; {
    vm::ExternModule::new(vm, primitive!(1 factorial))
}

let vm = new_vm();

// Introduce a module that can be loaded with `import! factorial`
add_extern_module(&amp;vm, &quot;factorial&quot;, load_factorial);

let expr = r#&quot;
    let factorial = import! factorial
    factorial 5
&quot;#;

let (result, _) = Compiler::new()
    .run_expr_async::&lt;i32&gt;(&amp;vm, &quot;factorial&quot;, expr)
    .sync_or_error()
    .unwrap();

assert_eq!(result, 120);
</code></pre>
<p><a href="https://docs.rs/gluon/*/gluon/import/fn.add_extern_module.html">add_extern_module</a> can do more than just exposing simple functions. For instance, the <a href="https://github.com/gluon-lang/gluon/blob/master/vm/src/primitives.rs">primitives</a> module export large parts of Rust's <a href="http://doc.rust-lang.org/std/primitive.str.html">string</a> and <a href="http://doc.rust-lang.org/std/primitive.f64.html">float</a> modules directly as records in Gluon under the <code>str</code> and <code>float</code> modules respectively.</p>
<pre><code class="language-rust ignore">let vm = new_vm();
let (result, _) = Compiler::new()
    .run_expr::&lt;String&gt;(&amp;vm, &quot;example&quot;, &quot; let string  = import! \&quot;std/string.glu\&quot; in string.trim \&quot;  Hello world  \t\&quot; &quot;)
    .unwrap();
assert_eq!(result, &quot;Hello world&quot;);
</code></pre>
<a class="header" href="print.html#marshalling-types" id="marshalling-types"><h1>Marshalling types</h1></a>
<p>An important part of embedding Gluon is translating non-primitive types from Gluon types to
Rust types and vice versa, allowing you to seamlessly implement rich APIs with complex types.
This translation is called <em>marshalling</em>.</p>
<a class="header" href="print.html#required-traits" id="required-traits"><h2>Required traits</h2></a>
<p>Gluon provides several traits for safely marshalling types to and from Gluon code:</p>
<ul>
<li>
<p><a href="https://docs.rs/gluon_vm/*/gluon_vm/api/trait.VmType.html">VmType</a> provides a mapping between Rust and Gluon types. It specifies the Gluon type
the implementing Rust type represents. All types that want to cross the Gluon/Rust boundary
must implement this trait.</p>
</li>
<li>
<p><a href="https://docs.rs/gluon_vm/*/gluon_vm/api/trait.Getable.html">Getable</a>: Types that implement <code>Getable</code> can be marshalled from Gluon to Rust. This
means you can use these types anywhere you are receiving values from Gluon, for example
as parameters for a function implemented on the Rust side or as return type of a Gluon
function you want to call from Rust.</p>
</li>
<li>
<p><a href="https://docs.rs/gluon_vm/*/gluon_vm/api/trait.Pushable.html">Pushable</a> is the counterpart to <code>Getable</code>. It allows implementing types to be marshalled
to Gluon. Values of these types can returned from embedded Rust functions and be used as
parameters to Gluon functions.</p>
</li>
<li>
<p><a href="https://docs.rs/gluon_vm/*/gluon_vm/api/trait.Userdata.html">Userdata</a> allows a Rust type to be marshalled as completely opaque type. The Gluon code
will be able to receive and pass values of this type, but cannot inspect it at all. This is
useful for passing handle-like values, that will be mostly used by the Rust code. <code>Pushable</code> is automatically implemented for all types that implement <code>Userdata</code>. <code>Getable</code> is automatically implemented for <code>&amp;T where T: Userdata</code> when used as argument to a Rust function, for places <code>OpaqueValue</code> can be used as a smart pointer around a <code>Userdata</code> value or the <code>UserdataValue</code> extractor can be used to clone the value.</p>
</li>
</ul>
<p>Gluon already provides implementations for the primitive and common standard library types.</p>
<a class="header" href="print.html#implementing-the-marshalling-traits-for-your-types" id="implementing-the-marshalling-traits-for-your-types"><h2>Implementing the marshalling traits for your types</h2></a>
<p>You can implement all of the above traits by hand, but for most cases you can also use the
derive macros in <a href="https://docs.rs/gluon_codegen/0.7.1/gluon_codegen/">gluon_codegen</a>.</p>
<p>You will also have to register the correct Gluon type. If you are marshalling <code>Userdata</code>, you
can use <code>Thread::register_type</code>, otherwise you will need to provide the complete type definition
in Gluon. When using the <code>serialization</code> feature, you can automatically generate the source
code using the <code>api::typ::make_source</code> function.</p>
<a class="header" href="print.html#using-derive-macros" id="using-derive-macros"><h3>Using derive macros</h3></a>
<p>Add the <code>gluon_codegen</code> crate to your <code>Cargo.toml</code> and import it:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate gluon_codegen;
</code></pre>
<p><code>VmType</code>, <code>Getable</code> and <code>Pushable</code> can be derived for types that consist only of types that
already implement the respective traits. In the case of <code>VmType</code> you also have to specify
the Gluon type the Rust type maps to, using the <code>#[gluon(vm_type = &quot;&lt;gluon_type&gt;&quot;)]</code> attribute.</p>
<p><code>Userdata</code> can be derived for any type as long as it is <code>Debug + Send + Sync</code> and has a <code>'static</code>
lifetime.</p>
<a class="header" href="print.html#implementing-by-hand" id="implementing-by-hand"><h3>Implementing by hand</h3></a>
<p>The following examples will all assume a simple struct <code>User&lt;T&gt;</code>, which is defined in a different
crate (You can find the full code in the <a href="https://github.com/gluon-lang/gluon/blob/master/examples/marshalling.rs">marshalling example</a>). To implement the marshalling traits,
we have to create a wrapper and implement the traits for it.</p>
<pre><code class="language-rust ignore">// defined by a different crate
struct User&lt;T&gt; {
    name: String,
    age: u32,
    data: T,
}
</code></pre>
<a class="header" href="print.html#vmtype" id="vmtype"><h4>VmType</h4></a>
<p><code>VmType</code> requires you to specify the Rust type that maps to the correct Gluon type. You can
simply assign <code>Self</code>. The heart of the trait is the <code>make_type</code> function. To get the correct
Gluon type, you will have to look it up from the vm, using the fully qualified type name:</p>
<pre><code class="language-rust ignore">let ty = vm.find_type_info(&quot;examples.wrapper.User&quot;)
    .expect(&quot;Could not find type&quot;)
    .into_type();
</code></pre>
<p>If you have a non generic type, this is all you need. In our case, we will have to apply the
generic type parameters first:</p>
<pre><code class="language-rust ignore">let mut vec = AppVec::new();
vec.push(T::make_type(vm));
Type::app(ty, vec)
</code></pre>
<p>You simply push all parameters to the <code>AppVec</code> in the order of their declaration, and then
use <code>Type::app</code> to construct the complete type.</p>
<a class="header" href="print.html#getable" id="getable"><h4>Getable</h4></a>
<p><code>Getable</code> only has one function you need to implement, <code>from_value</code>. It supplies a reference
to the vm and the raw data, from which you have to construct your type. Since we are implementing
<code>Getable</code> for a complex type, we are only interested in the <code>ValueRef::Data</code> variant.</p>
<pre><code class="language-rust ignore">let data = match data.as_ref() {
    ValueRef::Data(data) =&gt; data,
    _ =&gt; panic!(&quot;Value is not a complex type&quot;),
};
</code></pre>
<p>From <code>data</code> we can now extract the individual fields, using <code>lookup_field</code> for named fields or
<code>get_variant</code> for unnamed fields (like in tuple structs or variants).</p>
<pre><code class="language-rust ignore">// once we have the field's value, we construct the correct type
// using its Getable implementation
let name = String::from_value(vm, data.lookup_field(vm, &quot;name&quot;).unwrap();
</code></pre>
<p>In this example we used a struct, but if we wanted to construct an enum, we need to find out
what variant we are dealing with first, using the <code>tag</code> method:</p>
<pre><code class="language-rust ignore">match data.tag() {
    0 =&gt; // build first variant
    1 =&gt; // build second variant
    // ...
}
</code></pre>
<a class="header" href="print.html#pushable" id="pushable"><h4>Pushable</h4></a>
<p>To implement <code>Pushable</code>, we need to interact with Gluon's stack directly. The goal is to create
a <code>Value</code> that represents our Rust value, and push it on the stack. In order to do that, we need to
get the <code>Value</code>s for the fields of our type. We do that by pushing them to the stack in reverse
order and then popping the values from the stack:</p>
<pre><code class="language-rust ignore">self.inner.data.push(vm, ctx)?;
self.inner.age.push(vm, ctx)?;
self.inner.name.push(vm, ctx)?

let fields = [ctx.stack.pop(), ctx.stack.pop(), ctx.stack.pop()];
</code></pre>
<p>The <code>Context</code> we get passed has a convenience method for quickly constructing a complex type.
We can then push our final <code>Value</code>.</p>
<pre><code class="language-rust ignore">let val = ctx.new_data(vm, 0, &amp;fields)?;
ctx.stack.push(val);
</code></pre>
<p>If we were pushing an enum, we would also have to make sure that we are passing the correct
tag:</p>
<pre><code class="language-rust ignore">let val = match an_enum {
    Enum::VariantOne =&gt; ctx.new_data(vm, 0, &amp;fields),
    Enum::VariantTwo =&gt; ctx.new_data(vm, 1, &amp;fields),
}?;
</code></pre>
<a class="header" href="print.html#userdata" id="userdata"><h4>Userdata</h4></a>
<p>Implementing <code>Userdata</code> is straight forward: there are no required methods, so we can simply
use the default implementation. However, <code>Userdata</code> also requires the type to implement
<code>VmType</code> and <code>Traverseable</code>. We can use the minimal <code>VmType</code> implementation, it already
provides the correct <code>make_type</code> function for us:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; VmType for GluonUser&lt;T&gt;
where
    T: 'static + Debug + Sync + Send
{
    type Type = Self;
}
</code></pre>
<p>In our case, the <code>Traverseable</code> implementation can also be left empty. Only if a type contains
types that are managed by Gluon's GC, it is necessary to implement the <code>traverse</code> method
in order to call <code>traverse</code> on those types. This way the GC can find all the value it manages.</p>
<pre><code class="language-rust ignore">// empty impl for 'normal' types
impl&lt;T&gt; Traverseable for GluonUser&lt;T&gt; {}

// for a type that contains a Traversable type, we need to call
// its traverse method
impl Traverseable for ContainsGcPtr {
    fn traverse(&amp;self, gc: &amp;mut Gc) {
        self.gc_ptr.traverse(gc);
    }
}
</code></pre>
<a class="header" href="print.html#passing-values-to-and-from-gluon" id="passing-values-to-and-from-gluon"><h2>Passing values to and from Gluon</h2></a>
<p>Once your type implements the <a href="print.html#required-traits">required traits</a>, you can simply use it in
any function you want to expose to Gluon.</p>
<p>If you want to receive or return types with generic type parameters that are instantiated on
the Gluon side, you can use the <a href="https://docs.rs/gluon_vm/*/gluon_vm/api/struct.Generic.html">Generic</a> type together with the enums in the
<a href="https://docs.rs/gluon_vm/*/gluon_vm/api/generic/index.html">generic</a> module:</p>
<pre><code class="language-rust ignore">// we define Either with type parameters, just like in Gluon
#[derive(Getable, Pushable, VmType)]
#[gluon(vm_type = &quot;examples.either.Either&quot;)]
enum Either&lt;L, R&gt; {
    Left(L),
    Right(R),
}

// the function takes an Either instantiated with the `Generic` struct,
// which will handle the generic Gluon values for us
use gluon::vm::api::generic::{L, R};
use gluon::vm::api::Generic;

fn flip(either: Either&lt;Generic&lt;L&gt;, Generic&lt;R&gt;&gt;) -&gt; Either&lt;Generic&lt;R&gt;, Generic&lt;L&gt;&gt; {
    match either {
        Either::Left(val) =&gt; Either::Right(val),
        Either::Right(val) =&gt; Either::Left(val),
    }
}
</code></pre>
<p>Now we can pass <code>Either</code> to our Rust function:</p>
<pre><code class="language-f# ignore">// Either is defined as:
// type Either l r = | Left l | Right r
let either: forall r . Either String r = Left &quot;hello rust!&quot;

// we can pass the generic Either to the Rust function without an issue
do _ =
    match flip either with
    | Left _ -&gt; error &quot;unreachable!&quot;
    | Right val -&gt; io.println (&quot;Right is: &quot; &lt;&gt; val)

// using an Int instead also works
let either: forall r . Either Int r = Left 42

match flip either with
| Left _ -&gt; error &quot;also unreachable!&quot;
| Right 42 -&gt; io.println &quot;this is the right answer&quot;
| Right _ -&gt; error &quot;wrong answer!&quot;
</code></pre>
<a class="header" href="print.html#standard-types-and-functions" id="standard-types-and-functions"><h1>Standard types and functions</h1></a>
<p>https://gluon-lang.org/doc/nightly/std/index.html</p>
<p>TODO</p>
<a class="header" href="print.html#prelude" id="prelude"><h3>Prelude</h3></a>
<p>When compiling an expression, the compiler automatically inserts a small prelude before the expression itself, which gives automatic access to basic operators such as <code>+</code>, <code>-</code>, etc as well as types such as <code>Option</code> and <code>Result</code>.</p>
<a class="header" href="print.html#threads-and-channels" id="threads-and-channels"><h3>Threads and channels</h3></a>
<p>Gluon has support for cooperative threading and communication between them through the <code>Thread</code> and <code>Sender</code>/<code>Receiver</code> types.</p>
<p>TODO</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
